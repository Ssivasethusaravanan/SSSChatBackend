"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlchemyProvider = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const chains_1 = require("viem/chains");
const chains_js_1 = require("./chains.js");
const gas_fees_js_1 = require("./middleware/gas-fees.js");
const gas_manager_js_1 = require("./middleware/gas-manager.js");
const simulate_uo_js_1 = require("./middleware/simulate-uo.js");
const schema_js_1 = require("./schema.js");
class AlchemyProvider extends aa_core_1.SmartAccountProvider {
    constructor(config) {
        schema_js_1.AlchemyProviderConfigSchema.parse(config);
        const { chain, entryPointAddress, opts, feeOpts, ...connectionConfig } = config;
        const _chain = typeof chain === "number" ? chains_js_1.SupportedChains.get(chain) : chain;
        if (!_chain || !_chain.rpcUrls["alchemy"]) {
            throw new Error(`AlchemyProvider: chain (${chain}) not supported`);
        }
        const rpcUrl = connectionConfig.rpcUrl == null
            ? `${_chain.rpcUrls.alchemy.http[0]}/${connectionConfig.apiKey ?? ""}`
            : connectionConfig.rpcUrl;
        const client = (0, aa_core_1.createPublicErc4337Client)({
            chain: _chain,
            rpcUrl,
            ...(connectionConfig.jwt != null && {
                fetchOptions: {
                    headers: {
                        Authorization: `Bearer ${connectionConfig.jwt}`,
                    },
                },
            }),
        });
        super({
            rpcProvider: client,
            entryPointAddress,
            chain: _chain,
            opts,
        });
        Object.defineProperty(this, "pvgBuffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "feeOptsSet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rpcUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "gasEstimator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (struct) => {
                const request = (0, aa_core_1.deepHexlify)(await (0, aa_core_1.resolveProperties)(struct));
                const estimates = await this.rpcClient.estimateUserOperationGas(request, this.getEntryPointAddress());
                estimates.preVerificationGas =
                    (BigInt(estimates.preVerificationGas) * (100n + this.pvgBuffer)) / 100n;
                return {
                    ...struct,
                    ...estimates,
                };
            }
        });
        Object.defineProperty(this, "simulateUserOperationAssetChanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (data, overrides) => {
                const uoStruct = (0, aa_core_1.deepHexlify)(await this.buildUserOperation(data, overrides));
                return this.rpcClient.request({
                    method: "alchemy_simulateUserOperationAssetChanges",
                    params: [uoStruct, this.getEntryPointAddress()],
                });
            }
        });
        (0, gas_fees_js_1.withAlchemyGasFeeEstimator)(this, feeOpts?.baseFeeBufferPercent ?? 50n, feeOpts?.maxPriorityFeeBufferPercent ?? 5n);
        if (feeOpts?.preVerificationGasBufferPercent) {
            this.pvgBuffer = feeOpts?.preVerificationGasBufferPercent;
        }
        else if (new Set([
            chains_1.arbitrum.id,
            chains_1.arbitrumGoerli.id,
            chains_1.optimism.id,
            chains_1.optimismGoerli.id,
        ]).has(this.chain.id)) {
            this.pvgBuffer = 5n;
        }
        else {
            this.pvgBuffer = 0n;
        }
        this.feeOptsSet = !!feeOpts;
        this.rpcUrl = rpcUrl;
    }
    withAlchemyGasManager(config) {
        if (!this.isConnected()) {
            throw new Error("AlchemyProvider: account is not set, did you call `connect` first?");
        }
        return (0, gas_manager_js_1.withAlchemyGasManager)(this, config, !this.feeOptsSet);
    }
    withAlchemyUserOpSimulation() {
        if (!this.isConnected()) {
            throw new Error("AlchemyProvider: account is not set, did you call `connect` first?");
        }
        return (0, simulate_uo_js_1.withAlchemyUserOpSimulation)(this);
    }
    withAlchemyEnhancedApis(alchemy) {
        schema_js_1.AlchemySdkClientSchema.parse(alchemy);
        if (alchemy.config.url && alchemy.config.url !== this.rpcUrl) {
            throw new Error("Alchemy SDK client JSON-RPC URL must match AlchemyProvider JSON-RPC URL");
        }
        const alchemyUrl = `https://${alchemy.config.network}.g.alchemy.com/v2/${alchemy.config.apiKey}`;
        if (alchemyUrl !== this.rpcUrl) {
            throw new Error("Alchemy SDK client JSON-RPC URL must match AlchemyProvider JSON-RPC URL");
        }
        return this.extend(() => {
            return {
                core: alchemy.core,
                nft: alchemy.nft,
                transact: alchemy.transact,
                debug: alchemy.debug,
                ws: alchemy.ws,
                notify: alchemy.notify,
                config: alchemy.config,
            };
        });
    }
}
exports.AlchemyProvider = AlchemyProvider;
//# sourceMappingURL=provider.js.map