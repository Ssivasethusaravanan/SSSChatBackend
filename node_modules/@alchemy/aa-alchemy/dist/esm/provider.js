import { SmartAccountProvider, createPublicErc4337Client, deepHexlify, resolveProperties, } from "@alchemy/aa-core";
import { Alchemy } from "alchemy-sdk";
import {} from "viem";
import { arbitrum, arbitrumGoerli, optimism, optimismGoerli, } from "viem/chains";
import { SupportedChains } from "./chains.js";
import { withAlchemyGasFeeEstimator } from "./middleware/gas-fees.js";
import { withAlchemyGasManager, } from "./middleware/gas-manager.js";
import { withAlchemyUserOpSimulation } from "./middleware/simulate-uo.js";
import { AlchemyProviderConfigSchema, AlchemySdkClientSchema, } from "./schema.js";
export class AlchemyProvider extends SmartAccountProvider {
    constructor(config) {
        AlchemyProviderConfigSchema.parse(config);
        const { chain, entryPointAddress, opts, feeOpts, ...connectionConfig } = config;
        const _chain = typeof chain === "number" ? SupportedChains.get(chain) : chain;
        if (!_chain || !_chain.rpcUrls["alchemy"]) {
            throw new Error(`AlchemyProvider: chain (${chain}) not supported`);
        }
        const rpcUrl = connectionConfig.rpcUrl == null
            ? `${_chain.rpcUrls.alchemy.http[0]}/${connectionConfig.apiKey ?? ""}`
            : connectionConfig.rpcUrl;
        const client = createPublicErc4337Client({
            chain: _chain,
            rpcUrl,
            ...(connectionConfig.jwt != null && {
                fetchOptions: {
                    headers: {
                        Authorization: `Bearer ${connectionConfig.jwt}`,
                    },
                },
            }),
        });
        super({
            rpcProvider: client,
            entryPointAddress,
            chain: _chain,
            opts,
        });
        Object.defineProperty(this, "pvgBuffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "feeOptsSet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rpcUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "gasEstimator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (struct) => {
                const request = deepHexlify(await resolveProperties(struct));
                const estimates = await this.rpcClient.estimateUserOperationGas(request, this.getEntryPointAddress());
                estimates.preVerificationGas =
                    (BigInt(estimates.preVerificationGas) * (100n + this.pvgBuffer)) / 100n;
                return {
                    ...struct,
                    ...estimates,
                };
            }
        });
        Object.defineProperty(this, "simulateUserOperationAssetChanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (data, overrides) => {
                const uoStruct = deepHexlify(await this.buildUserOperation(data, overrides));
                return this.rpcClient.request({
                    method: "alchemy_simulateUserOperationAssetChanges",
                    params: [uoStruct, this.getEntryPointAddress()],
                });
            }
        });
        withAlchemyGasFeeEstimator(this, feeOpts?.baseFeeBufferPercent ?? 50n, feeOpts?.maxPriorityFeeBufferPercent ?? 5n);
        if (feeOpts?.preVerificationGasBufferPercent) {
            this.pvgBuffer = feeOpts?.preVerificationGasBufferPercent;
        }
        else if (new Set([
            arbitrum.id,
            arbitrumGoerli.id,
            optimism.id,
            optimismGoerli.id,
        ]).has(this.chain.id)) {
            this.pvgBuffer = 5n;
        }
        else {
            this.pvgBuffer = 0n;
        }
        this.feeOptsSet = !!feeOpts;
        this.rpcUrl = rpcUrl;
    }
    withAlchemyGasManager(config) {
        if (!this.isConnected()) {
            throw new Error("AlchemyProvider: account is not set, did you call `connect` first?");
        }
        return withAlchemyGasManager(this, config, !this.feeOptsSet);
    }
    withAlchemyUserOpSimulation() {
        if (!this.isConnected()) {
            throw new Error("AlchemyProvider: account is not set, did you call `connect` first?");
        }
        return withAlchemyUserOpSimulation(this);
    }
    withAlchemyEnhancedApis(alchemy) {
        AlchemySdkClientSchema.parse(alchemy);
        if (alchemy.config.url && alchemy.config.url !== this.rpcUrl) {
            throw new Error("Alchemy SDK client JSON-RPC URL must match AlchemyProvider JSON-RPC URL");
        }
        const alchemyUrl = `https://${alchemy.config.network}.g.alchemy.com/v2/${alchemy.config.apiKey}`;
        if (alchemyUrl !== this.rpcUrl) {
            throw new Error("Alchemy SDK client JSON-RPC URL must match AlchemyProvider JSON-RPC URL");
        }
        return this.extend(() => {
            return {
                core: alchemy.core,
                nft: alchemy.nft,
                transact: alchemy.transact,
                debug: alchemy.debug,
                ws: alchemy.ws,
                notify: alchemy.notify,
                config: alchemy.config,
            };
        });
    }
}
//# sourceMappingURL=provider.js.map